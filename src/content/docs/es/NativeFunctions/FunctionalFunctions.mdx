---
title: Funciones Funcionales
description: Guía para Funciones Funcionales
sidebar:
  order: 6
---
import PyTable from '@components/PyTable.astro';
import { Code } from "@astrojs/starlight/components"

Estas funciones permiten aplicar operaciones de forma declarativa y funcional sobre colecciones de datos, como listas o tuplas. Son especialmente útiles cuando se requiere aplicar una función a muchos elementos (map), filtrar según condiciones (filter), combinar datos (zip) o generar secuencias numéricas (range). Su uso favorece un estilo de programación más limpio, compacto y expresivo.

<PyTable 
  headers={["Función", "Descripción"]}
  rows={[
    ["map()", "Aplica una función a cada elemento de un iterable y devuelve un nuevo iterable."],
    ["filter()", "Filtra los elementos de un iterable según una condición dada."],
    ["zip()", "Une varios iterables en pares ordenados, como tuplas."],
    ["range()", "Genera una secuencia de números, generalmente usada en bucles."],
    ["all()", "Retorna True si todos los elementos de un iterable son verdaderos."],
    ["any()", "Retorna True si al menos un elemento es verdadero."],

  
  ]}
/>
A continuacion te explicare con mas detalle el funcionamiento de estas funciones:

### <code>map()</code>

Uso típico: Aplicar una función a cada elemento de un iterable y devolver un nuevo iterable.
<Code 
code="
numeros = [1, 2, 3, 4]
al_cuadrado = map(lambda x: x ** 2, numeros)
print(list(al_cuadrado))
"
lang="py" 
title="map.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
[1, 4, 9, 16]
"

title="map.py" 
mark="highlights"
frame='terminal' />

### <code>filter()</code>

Uso típico: Filtrar los elementos de un iterable que cumplan una condición.

<Code 
code="
numeros = [10, 15, 20, 25]
mayores_que_15 = filter(lambda x: x > 15, numeros)
print(list(mayores_que_15))
"
lang="py" 
title="filter.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
[20, 25]
"

title="filter.py" 
mark="highlights"
frame='terminal' />

### <code>zip()</code>

Uso típico: Combinar varios iterables en pares ordenados (tuplas).
<Code 
code="
nombres  = ['Ana', 'Luis', 'Sofía']
edades   = [28, 34, 25]
parejas  = zip(nombres, edades)
print(list(parejas))
"
lang="py" 
title="zip.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
[('Ana', 28), ('Luis', 34), ('Sofía', 25)]
"

title="zip.py" 
mark="highlights"
frame='terminal' />


### <code>range()</code>

Uso típico: Generar una secuencia numérica, comúnmente usada en bucles.

<Code 
code="
for numero in range(0, 10, 2):  # De 0 a 8 en pasos de 2
&nbsp;&nbsp;&nbsp;&nbsp;print(numero, end'')
"
lang="py" 
title="range.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
[('Ana', 28), ('Luis', 34), ('Sofía', 25)]
"

title="range.py" 
mark="highlights"
frame='terminal' />

### <code>all()</code>

Uso típico: Verificar si todos los elementos de un iterable son verdaderos.

<Code 
code="
valores = [True, 1, 5 > 2]
print(all(valores))
"
lang="py" 
title="all.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
True
"

title="all.py" 
mark="highlights"
frame='terminal' />

### <code>any()</code>

Uso típico: Verificar si al menos uno de los elementos de un iterable es verdadero.

<Code 
code="
valores = [0, '', None, 7]
print(any(valores))
"
lang="py" 
title="any.py" 
mark="highlights"
frame='auto' />
Salida: 
<Code 
code="
True
"

title="any.py" 
mark="highlights"
frame='terminal' />
